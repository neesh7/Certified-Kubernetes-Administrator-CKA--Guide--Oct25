
## Encryption at Rest in K8's

```bash
# to check if encryption at rest is already enabled
$ ps -aux | grep kube-api | grep "encryption-provider-config"
```
**Encryption at rest **in **Kubernetes** **protects sensitive data** (like Secrets, ConfigMaps, and Persistent Volumes) **by encrypting it before it's written to etcd**.

Note: as etcd doesn't provides any encryption by default, so we have to use Encryption at rest

🔐 What It Does:
- Encrypts Kubernetes resource data stored in etcd.

- Helps meet security and compliance requirements (e.g., GDPR, HIPAA).

🧩 How It Works:
- Kubernetes uses encryption providers defined in an encryption configuration file. Supported providers:

- **aescbc** (recommended)

- **kms** (for external key management via providers like HashiCorp Vault, AWS KMS)

- **secretbox**

- **identity** (no encryption, for testing/migration)

📄 Sample Encryption Config:
```yaml
apiVersion: apiserver.config.k8s.io/v1
kind: EncryptionConfiguration
resources:
  - resources:
      - secrets
    providers:
      - aescbc:
          keys:
            - name: key1
              secret: <base64-encoded-32-byte-key>
      - identity: {}
  ```    
📌 Steps to Enable:
1. Generate a 32-byte base64-encoded key:

```bash
$ head -c 32 /dev/urandom | base64
```
2. Create the encryption config file and save it to a secure path on the master node.

3. Edit the kube-apiserver manifest (usually under /etc/kubernetes/manifests/kube-apiserver.yaml) and add:

```yaml
--encryption-provider-config=/path/to/encryption-config.yaml
Restart kube-apiserver (will restart automatically if managed as a static pod).
```
4. 🔁 Re-encrypt Existing Data (Optional):
Use this to encrypt data that already exists in etcd:

```bash
$ kubectl get secrets --all-namespaces -o json | \
$ kubectl replace -f -
```